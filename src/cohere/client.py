# This file was auto-generated by Fern from our API Definition.

import json
import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import typing_extensions

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .environment import ClientEnvironment
from .errors.bad_request_error import BadRequestError
from .errors.internal_server_error import InternalServerError
from .errors.too_many_requests_error import TooManyRequestsError
from .resources.connectors.client import AsyncConnectorsClient, ConnectorsClient
from .resources.datasets.client import AsyncDatasetsClient, DatasetsClient
from .resources.embed_jobs.client import AsyncEmbedJobsClient, EmbedJobsClient
from .types.chat_connector import ChatConnector
from .types.chat_document import ChatDocument
from .types.chat_message import ChatMessage
from .types.chat_request_citation_quality import ChatRequestCitationQuality
from .types.chat_request_prompt_truncation import ChatRequestPromptTruncation
from .types.chat_stream_request_citation_quality import ChatStreamRequestCitationQuality
from .types.chat_stream_request_prompt_truncation import ChatStreamRequestPromptTruncation
from .types.classify_example import ClassifyExample
from .types.classify_request_truncate import ClassifyRequestTruncate
from .types.classify_response import ClassifyResponse
from .types.detokenize_response import DetokenizeResponse
from .types.embed_input_type import EmbedInputType
from .types.embed_request_embedding_types_item import EmbedRequestEmbeddingTypesItem
from .types.embed_request_truncate import EmbedRequestTruncate
from .types.embed_response import EmbedResponse
from .types.generate_request_return_likelihoods import GenerateRequestReturnLikelihoods
from .types.generate_request_truncate import GenerateRequestTruncate
from .types.generate_stream_request_return_likelihoods import GenerateStreamRequestReturnLikelihoods
from .types.generate_stream_request_truncate import GenerateStreamRequestTruncate
from .types.generate_streamed_response import GenerateStreamedResponse
from .types.generation import Generation
from .types.non_streamed_chat_response import NonStreamedChatResponse
from .types.rerank_request_documents_item import RerankRequestDocumentsItem
from .types.rerank_response import RerankResponse
from .types.streamed_chat_response import StreamedChatResponse
from .types.summarize_request_extractiveness import SummarizeRequestExtractiveness
from .types.summarize_request_format import SummarizeRequestFormat
from .types.summarize_request_length import SummarizeRequestLength
from .types.summarize_response import SummarizeResponse
from .types.tokenize_response import TokenizeResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class Client:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: ClientEnvironment = ClientEnvironment.PRODUCTION,
        client_name: typing.Optional[str] = None,
        token: typing.Union[str, typing.Callable[[], str]],
        timeout: typing.Optional[float] = 60,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            client_name=client_name,
            token=token,
            httpx_client=httpx.Client(timeout=timeout) if httpx_client is None else httpx_client,
        )
        self.embed_jobs = EmbedJobsClient(client_wrapper=self._client_wrapper)
        self.datasets = DatasetsClient(client_wrapper=self._client_wrapper)
        self.connectors = ConnectorsClient(client_wrapper=self._client_wrapper)

    def chat_stream(
        self,
        *,
        message: str,
        model: typing.Optional[str] = OMIT,
        stream: typing_extensions.Literal[True],
        preamble_override: typing.Optional[str] = OMIT,
        chat_history: typing.Optional[typing.List[ChatMessage]] = OMIT,
        conversation_id: typing.Optional[str] = OMIT,
        prompt_truncation: typing.Optional[ChatStreamRequestPromptTruncation] = OMIT,
        connectors: typing.Optional[typing.List[ChatConnector]] = OMIT,
        search_queries_only: typing.Optional[bool] = OMIT,
        documents: typing.Optional[typing.List[ChatDocument]] = OMIT,
        citation_quality: typing.Optional[ChatStreamRequestCitationQuality] = OMIT,
        temperature: typing.Optional[float] = OMIT,
        max_tokens: typing.Optional[int] = OMIT,
        k: typing.Optional[int] = OMIT,
        p: typing.Optional[float] = OMIT,
        frequency_penalty: typing.Optional[float] = OMIT,
        presence_penalty: typing.Optional[float] = OMIT,
    ) -> typing.Iterator[StreamedChatResponse]:
        """
        The `chat` endpoint allows users to have conversations with a Large Language Model (LLM) from Cohere. Users can send messages as part of a persisted conversation using the `conversation_id` parameter, or they can pass in their own conversation history using the `chat_history` parameter.

        The endpoint features additional parameters such as [connectors](https://docs.cohere.com/docs/connectors) and `documents` that enable conversations enriched by external knowledge. We call this ["Retrieval Augmented Generation"](https://docs.cohere.com/docs/retrieval-augmented-generation-rag), or "RAG". For a full breakdown of the Chat API endpoint, document and connector modes, and streaming (with code samples), see [this guide](https://docs.cohere.com/docs/cochat-beta).

        Parameters:
            - message: str. Accepts a string.
                            The chat message from the user to the model.

            - model: typing.Optional[str]. Defaults to `command`.

                                           The identifier of the model, which can be one of the existing Cohere models or the full ID for a [fine-tuned custom model](https://docs.cohere.com/docs/chat-fine-tuning).

                                           Compatible Cohere models are `command` and `command-light` as well as the experimental `command-nightly` and `command-light-nightly` variants. Read more about [Cohere models](https://docs.cohere.com/docs/models).

            - stream: typing_extensions.Literal[True].

            - preamble_override: typing.Optional[str]. When specified, the default Cohere preamble will be replaced with the provided one.

            - chat_history: typing.Optional[typing.List[ChatMessage]]. A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's `message`.

            - conversation_id: typing.Optional[str]. An alternative to `chat_history`. Previous conversations can be resumed by providing the conversation's identifier. The contents of `message` and the model's response will be stored as part of this conversation.

                                                     If a conversation with this id does not already exist, a new conversation will be created.

            - prompt_truncation: typing.Optional[ChatStreamRequestPromptTruncation]. Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.

                                                                                     Dictates how the prompt will be constructed.

                                                                                     With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.

                                                                                     With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.

            - connectors: typing.Optional[typing.List[ChatConnector]]. Accepts `{"id": "web-search"}`, and/or the `"id"` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.

                                                                       When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).

            - search_queries_only: typing.Optional[bool]. Defaults to `false`.

                                                          When `true`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's `message` will be generated.

            - documents: typing.Optional[typing.List[ChatDocument]]. A list of relevant documents that the model can use to enrich its reply. See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.

            - citation_quality: typing.Optional[ChatStreamRequestCitationQuality]. Defaults to `"accurate"`.

                                                                                   Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.

            - temperature: typing.Optional[float]. Defaults to `0.3`.

                                                   A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.

                                                   Randomness can be further maximized by increasing the  value of the `p` parameter.

            - max_tokens: typing.Optional[int]. The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.

            - k: typing.Optional[int]. Ensures only the top `k` most likely tokens are considered for generation at each step.
                                       Defaults to `0`, min value of `0`, max value of `500`.

            - p: typing.Optional[float]. Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
                                         Defaults to `0.75`. min value of `0.01`, max value of `0.99`.

            - frequency_penalty: typing.Optional[float]. Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.

            - presence_penalty: typing.Optional[float]. Defaults to `0.0`, min value of `0.0`, max value of `1.0`. Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
        """
        _request: typing.Dict[str, typing.Any] = {"message": message, "stream": stream}
        if model is not OMIT:
            _request["model"] = model
        if preamble_override is not OMIT:
            _request["preamble_override"] = preamble_override
        if chat_history is not OMIT:
            _request["chat_history"] = chat_history
        if conversation_id is not OMIT:
            _request["conversation_id"] = conversation_id
        if prompt_truncation is not OMIT:
            _request["prompt_truncation"] = prompt_truncation
        if connectors is not OMIT:
            _request["connectors"] = connectors
        if search_queries_only is not OMIT:
            _request["search_queries_only"] = search_queries_only
        if documents is not OMIT:
            _request["documents"] = documents
        if citation_quality is not OMIT:
            _request["citation_quality"] = citation_quality
        if temperature is not OMIT:
            _request["temperature"] = temperature
        if max_tokens is not OMIT:
            _request["max_tokens"] = max_tokens
        if k is not OMIT:
            _request["k"] = k
        if p is not OMIT:
            _request["p"] = p
        if frequency_penalty is not OMIT:
            _request["frequency_penalty"] = frequency_penalty
        if presence_penalty is not OMIT:
            _request["presence_penalty"] = presence_penalty
        with self._client_wrapper.httpx_client.stream(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/chat"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _text in _response.iter_lines():
                    if len(_text) == 0:
                        continue
                    yield pydantic.parse_obj_as(StreamedChatResponse, json.loads(_text))  # type: ignore
                return
            _response.read()
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def chat(
        self,
        *,
        message: str,
        model: typing.Optional[str] = OMIT,
        stream: typing_extensions.Literal[False],
        preamble_override: typing.Optional[str] = OMIT,
        chat_history: typing.Optional[typing.List[ChatMessage]] = OMIT,
        conversation_id: typing.Optional[str] = OMIT,
        prompt_truncation: typing.Optional[ChatRequestPromptTruncation] = OMIT,
        connectors: typing.Optional[typing.List[ChatConnector]] = OMIT,
        search_queries_only: typing.Optional[bool] = OMIT,
        documents: typing.Optional[typing.List[ChatDocument]] = OMIT,
        citation_quality: typing.Optional[ChatRequestCitationQuality] = OMIT,
        temperature: typing.Optional[float] = OMIT,
        max_tokens: typing.Optional[int] = OMIT,
        k: typing.Optional[int] = OMIT,
        p: typing.Optional[float] = OMIT,
        frequency_penalty: typing.Optional[float] = OMIT,
        presence_penalty: typing.Optional[float] = OMIT,
    ) -> NonStreamedChatResponse:
        """
        The `chat` endpoint allows users to have conversations with a Large Language Model (LLM) from Cohere. Users can send messages as part of a persisted conversation using the `conversation_id` parameter, or they can pass in their own conversation history using the `chat_history` parameter.

        The endpoint features additional parameters such as [connectors](https://docs.cohere.com/docs/connectors) and `documents` that enable conversations enriched by external knowledge. We call this ["Retrieval Augmented Generation"](https://docs.cohere.com/docs/retrieval-augmented-generation-rag), or "RAG". For a full breakdown of the Chat API endpoint, document and connector modes, and streaming (with code samples), see [this guide](https://docs.cohere.com/docs/cochat-beta).

        Parameters:
            - message: str. Accepts a string.
                            The chat message from the user to the model.

            - model: typing.Optional[str]. Defaults to `command`.

                                           The identifier of the model, which can be one of the existing Cohere models or the full ID for a [fine-tuned custom model](https://docs.cohere.com/docs/chat-fine-tuning).

                                           Compatible Cohere models are `command` and `command-light` as well as the experimental `command-nightly` and `command-light-nightly` variants. Read more about [Cohere models](https://docs.cohere.com/docs/models).

            - stream: typing_extensions.Literal[False].

            - preamble_override: typing.Optional[str]. When specified, the default Cohere preamble will be replaced with the provided one.

            - chat_history: typing.Optional[typing.List[ChatMessage]]. A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's `message`.

            - conversation_id: typing.Optional[str]. An alternative to `chat_history`. Previous conversations can be resumed by providing the conversation's identifier. The contents of `message` and the model's response will be stored as part of this conversation.

                                                     If a conversation with this id does not already exist, a new conversation will be created.

            - prompt_truncation: typing.Optional[ChatRequestPromptTruncation]. Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.

                                                                               Dictates how the prompt will be constructed.

                                                                               With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.

                                                                               With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.

            - connectors: typing.Optional[typing.List[ChatConnector]]. Accepts `{"id": "web-search"}`, and/or the `"id"` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.

                                                                       When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).

            - search_queries_only: typing.Optional[bool]. Defaults to `false`.

                                                          When `true`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's `message` will be generated.

            - documents: typing.Optional[typing.List[ChatDocument]]. A list of relevant documents that the model can use to enrich its reply. See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.

            - citation_quality: typing.Optional[ChatRequestCitationQuality]. Defaults to `"accurate"`.

                                                                             Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.

            - temperature: typing.Optional[float]. Defaults to `0.3`.

                                                   A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.

                                                   Randomness can be further maximized by increasing the  value of the `p` parameter.

            - max_tokens: typing.Optional[int]. The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.

            - k: typing.Optional[int]. Ensures only the top `k` most likely tokens are considered for generation at each step.
                                       Defaults to `0`, min value of `0`, max value of `500`.

            - p: typing.Optional[float]. Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
                                         Defaults to `0.75`. min value of `0.01`, max value of `0.99`.

            - frequency_penalty: typing.Optional[float]. Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.

            - presence_penalty: typing.Optional[float]. Defaults to `0.0`, min value of `0.0`, max value of `1.0`. Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
        ---
        from cohere import (
            ChatMessage,
            ChatMessageRole,
            ChatRequestCitationQuality,
            ChatRequestPromptOverride,
            ChatRequestPromptTruncation,
            ChatRequestSearchOptions,
        )
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.chat(
            message="Can you give me a global market overview of solar panels?",
            stream=False,
            chat_history=[
                ChatMessage(
                    role=ChatMessageRole.CHATBOT,
                    message="Hi!",
                ),
                ChatMessage(
                    role=ChatMessageRole.CHATBOT,
                    message="How can I help you today?",
                ),
            ],
            prompt_truncation=ChatRequestPromptTruncation.OFF,
            citation_quality=ChatRequestCitationQuality.FAST,
            temperature=0.3,
            search_options=ChatRequestSearchOptions(),
            prompt_override=ChatRequestPromptOverride(),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"message": message, "stream": stream}
        if model is not OMIT:
            _request["model"] = model
        if preamble_override is not OMIT:
            _request["preamble_override"] = preamble_override
        if chat_history is not OMIT:
            _request["chat_history"] = chat_history
        if conversation_id is not OMIT:
            _request["conversation_id"] = conversation_id
        if prompt_truncation is not OMIT:
            _request["prompt_truncation"] = prompt_truncation
        if connectors is not OMIT:
            _request["connectors"] = connectors
        if search_queries_only is not OMIT:
            _request["search_queries_only"] = search_queries_only
        if documents is not OMIT:
            _request["documents"] = documents
        if citation_quality is not OMIT:
            _request["citation_quality"] = citation_quality
        if temperature is not OMIT:
            _request["temperature"] = temperature
        if max_tokens is not OMIT:
            _request["max_tokens"] = max_tokens
        if k is not OMIT:
            _request["k"] = k
        if p is not OMIT:
            _request["p"] = p
        if frequency_penalty is not OMIT:
            _request["frequency_penalty"] = frequency_penalty
        if presence_penalty is not OMIT:
            _request["presence_penalty"] = presence_penalty
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/chat"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(NonStreamedChatResponse, _response.json())  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_stream(
        self,
        *,
        prompt: str,
        model: typing.Optional[str] = OMIT,
        num_generations: typing.Optional[int] = OMIT,
        stream: typing_extensions.Literal[True],
        max_tokens: typing.Optional[int] = OMIT,
        truncate: typing.Optional[GenerateStreamRequestTruncate] = OMIT,
        temperature: typing.Optional[float] = OMIT,
        preset: typing.Optional[str] = OMIT,
        end_sequences: typing.Optional[typing.List[str]] = OMIT,
        stop_sequences: typing.Optional[typing.List[str]] = OMIT,
        k: typing.Optional[int] = OMIT,
        p: typing.Optional[float] = OMIT,
        frequency_penalty: typing.Optional[float] = OMIT,
        presence_penalty: typing.Optional[float] = OMIT,
        return_likelihoods: typing.Optional[GenerateStreamRequestReturnLikelihoods] = OMIT,
        logit_bias: typing.Optional[typing.Dict[str, float]] = OMIT,
        raw_prompting: typing.Optional[bool] = OMIT,
    ) -> typing.Iterator[GenerateStreamedResponse]:
        """
        This endpoint generates realistic text conditioned on a given input.

        Parameters:
            - prompt: str. The input text that serves as the starting point for generating the response.
                           Note: The prompt will be pre-processed and modified before reaching the model.

            - model: typing.Optional[str]. The identifier of the model to generate with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental).
                                           Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
            - num_generations: typing.Optional[int]. The maximum number of generations that will be returned. Defaults to `1`, min value of `1`, max value of `5`.

            - stream: typing_extensions.Literal[True].

            - max_tokens: typing.Optional[int]. The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.

                                                This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.

                                                Can only be set to `0` if `return_likelihoods` is set to `ALL` to get the likelihood of the prompt.

            - truncate: typing.Optional[GenerateStreamRequestTruncate]. One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.

                                                                        Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

                                                                        If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
            - temperature: typing.Optional[float]. A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
                                                   Defaults to `0.75`, min value of `0.0`, max value of `5.0`.

            - preset: typing.Optional[str]. Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.ai/playground/generate).
                                            When a preset is specified, the `prompt` parameter becomes optional, and any included parameters will override the preset's parameters.

            - end_sequences: typing.Optional[typing.List[str]]. The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.

            - stop_sequences: typing.Optional[typing.List[str]]. The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.

            - k: typing.Optional[int]. Ensures only the top `k` most likely tokens are considered for generation at each step.
                                       Defaults to `0`, min value of `0`, max value of `500`.

            - p: typing.Optional[float]. Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
                                         Defaults to `0.75`. min value of `0.01`, max value of `0.99`.

            - frequency_penalty: typing.Optional[float]. Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.

                                                         Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.

            - presence_penalty: typing.Optional[float]. Defaults to `0.0`, min value of `0.0`, max value of `1.0`.

                                                        Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.

                                                        Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.

            - return_likelihoods: typing.Optional[GenerateStreamRequestReturnLikelihoods]. One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.

                                                                                           If `GENERATION` is selected, the token likelihoods will only be provided for generated text.

                                                                                           If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
            - logit_bias: typing.Optional[typing.Dict[str, float]]. Certain models support the `logit_bias` parameter.

                                                                    Used to prevent the model from generating unwanted tokens or to incentivize it to include desired tokens. The format is `{token_id: bias}` where bias is a float between -10 and 10. Tokens can be obtained from text using [Tokenize](/reference/tokenize).

                                                                    For example, if the value `{'11': -10}` is provided, the model will be very unlikely to include the token 11 (`"\n"`, the newline character) anywhere in the generated text. In contrast `{'11': 10}` will result in generations that nearly only contain that token. Values between -10 and 10 will proportionally affect the likelihood of the token appearing in the generated text.
            - raw_prompting: typing.Optional[bool]. When enabled, the user's prompt will be sent to the model without any pre-processing.
        """
        _request: typing.Dict[str, typing.Any] = {"prompt": prompt, "stream": stream}
        if model is not OMIT:
            _request["model"] = model
        if num_generations is not OMIT:
            _request["num_generations"] = num_generations
        if max_tokens is not OMIT:
            _request["max_tokens"] = max_tokens
        if truncate is not OMIT:
            _request["truncate"] = truncate
        if temperature is not OMIT:
            _request["temperature"] = temperature
        if preset is not OMIT:
            _request["preset"] = preset
        if end_sequences is not OMIT:
            _request["end_sequences"] = end_sequences
        if stop_sequences is not OMIT:
            _request["stop_sequences"] = stop_sequences
        if k is not OMIT:
            _request["k"] = k
        if p is not OMIT:
            _request["p"] = p
        if frequency_penalty is not OMIT:
            _request["frequency_penalty"] = frequency_penalty
        if presence_penalty is not OMIT:
            _request["presence_penalty"] = presence_penalty
        if return_likelihoods is not OMIT:
            _request["return_likelihoods"] = return_likelihoods
        if logit_bias is not OMIT:
            _request["logit_bias"] = logit_bias
        if raw_prompting is not OMIT:
            _request["raw_prompting"] = raw_prompting
        with self._client_wrapper.httpx_client.stream(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/generate"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _text in _response.iter_lines():
                    if len(_text) == 0:
                        continue
                    yield pydantic.parse_obj_as(GenerateStreamedResponse, json.loads(_text))  # type: ignore
                return
            _response.read()
            if _response.status_code == 400:
                raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate(
        self,
        *,
        prompt: str,
        model: typing.Optional[str] = OMIT,
        num_generations: typing.Optional[int] = OMIT,
        stream: typing_extensions.Literal[False],
        max_tokens: typing.Optional[int] = OMIT,
        truncate: typing.Optional[GenerateRequestTruncate] = OMIT,
        temperature: typing.Optional[float] = OMIT,
        preset: typing.Optional[str] = OMIT,
        end_sequences: typing.Optional[typing.List[str]] = OMIT,
        stop_sequences: typing.Optional[typing.List[str]] = OMIT,
        k: typing.Optional[int] = OMIT,
        p: typing.Optional[float] = OMIT,
        frequency_penalty: typing.Optional[float] = OMIT,
        presence_penalty: typing.Optional[float] = OMIT,
        return_likelihoods: typing.Optional[GenerateRequestReturnLikelihoods] = OMIT,
        logit_bias: typing.Optional[typing.Dict[str, float]] = OMIT,
        raw_prompting: typing.Optional[bool] = OMIT,
    ) -> Generation:
        """
        This endpoint generates realistic text conditioned on a given input.

        Parameters:
            - prompt: str. The input text that serves as the starting point for generating the response.
                           Note: The prompt will be pre-processed and modified before reaching the model.

            - model: typing.Optional[str]. The identifier of the model to generate with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental).
                                           Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
            - num_generations: typing.Optional[int]. The maximum number of generations that will be returned. Defaults to `1`, min value of `1`, max value of `5`.

            - stream: typing_extensions.Literal[False].

            - max_tokens: typing.Optional[int]. The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.

                                                This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.

                                                Can only be set to `0` if `return_likelihoods` is set to `ALL` to get the likelihood of the prompt.

            - truncate: typing.Optional[GenerateRequestTruncate]. One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.

                                                                  Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

                                                                  If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
            - temperature: typing.Optional[float]. A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
                                                   Defaults to `0.75`, min value of `0.0`, max value of `5.0`.

            - preset: typing.Optional[str]. Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.ai/playground/generate).
                                            When a preset is specified, the `prompt` parameter becomes optional, and any included parameters will override the preset's parameters.

            - end_sequences: typing.Optional[typing.List[str]]. The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.

            - stop_sequences: typing.Optional[typing.List[str]]. The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.

            - k: typing.Optional[int]. Ensures only the top `k` most likely tokens are considered for generation at each step.
                                       Defaults to `0`, min value of `0`, max value of `500`.

            - p: typing.Optional[float]. Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
                                         Defaults to `0.75`. min value of `0.01`, max value of `0.99`.

            - frequency_penalty: typing.Optional[float]. Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.

                                                         Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.

            - presence_penalty: typing.Optional[float]. Defaults to `0.0`, min value of `0.0`, max value of `1.0`.

                                                        Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.

                                                        Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.

            - return_likelihoods: typing.Optional[GenerateRequestReturnLikelihoods]. One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.

                                                                                     If `GENERATION` is selected, the token likelihoods will only be provided for generated text.

                                                                                     If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
            - logit_bias: typing.Optional[typing.Dict[str, float]]. Certain models support the `logit_bias` parameter.

                                                                    Used to prevent the model from generating unwanted tokens or to incentivize it to include desired tokens. The format is `{token_id: bias}` where bias is a float between -10 and 10. Tokens can be obtained from text using [Tokenize](/reference/tokenize).

                                                                    For example, if the value `{'11': -10}` is provided, the model will be very unlikely to include the token 11 (`"\n"`, the newline character) anywhere in the generated text. In contrast `{'11': 10}` will result in generations that nearly only contain that token. Values between -10 and 10 will proportionally affect the likelihood of the token appearing in the generated text.
            - raw_prompting: typing.Optional[bool]. When enabled, the user's prompt will be sent to the model without any pre-processing.
        ---
        from cohere import GenerateRequestReturnLikelihoods, GenerateRequestTruncate
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.generate(
            prompt="Please explain to me how LLMs work",
            stream=False,
            truncate=GenerateRequestTruncate.NONE,
            preset="my-preset-a58sbd",
            return_likelihoods=GenerateRequestReturnLikelihoods.GENERATION,
        )
        """
        _request: typing.Dict[str, typing.Any] = {"prompt": prompt, "stream": stream}
        if model is not OMIT:
            _request["model"] = model
        if num_generations is not OMIT:
            _request["num_generations"] = num_generations
        if max_tokens is not OMIT:
            _request["max_tokens"] = max_tokens
        if truncate is not OMIT:
            _request["truncate"] = truncate
        if temperature is not OMIT:
            _request["temperature"] = temperature
        if preset is not OMIT:
            _request["preset"] = preset
        if end_sequences is not OMIT:
            _request["end_sequences"] = end_sequences
        if stop_sequences is not OMIT:
            _request["stop_sequences"] = stop_sequences
        if k is not OMIT:
            _request["k"] = k
        if p is not OMIT:
            _request["p"] = p
        if frequency_penalty is not OMIT:
            _request["frequency_penalty"] = frequency_penalty
        if presence_penalty is not OMIT:
            _request["presence_penalty"] = presence_penalty
        if return_likelihoods is not OMIT:
            _request["return_likelihoods"] = return_likelihoods
        if logit_bias is not OMIT:
            _request["logit_bias"] = logit_bias
        if raw_prompting is not OMIT:
            _request["raw_prompting"] = raw_prompting
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/generate"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Generation, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def embed(
        self,
        *,
        texts: typing.List[str],
        model: typing.Optional[str] = OMIT,
        input_type: typing.Optional[EmbedInputType] = OMIT,
        embedding_types: typing.Optional[typing.List[EmbedRequestEmbeddingTypesItem]] = OMIT,
        truncate: typing.Optional[EmbedRequestTruncate] = OMIT,
    ) -> EmbedResponse:
        """
        This endpoint returns text embeddings. An embedding is a list of floating point numbers that captures semantic information about the text that it represents.

        Embeddings can be used to create text classifiers as well as empower semantic search. To learn more about embeddings, see the embedding page.

        If you want to learn more how to use the embedding model, have a look at the [Semantic Search Guide](/docs/semantic-search).

        Parameters:
            - texts: typing.List[str]. An array of strings for the model to embed. Maximum number of texts per call is `96`. We recommend reducing the length of each text to be under `512` tokens for optimal quality.

            - model: typing.Optional[str]. Defaults to embed-english-v2.0

                                           The identifier of the model. Smaller "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.

                                           Available models and corresponding embedding dimensions:

                                           * `embed-english-v3.0`  1024
                                           * `embed-multilingual-v3.0`  1024
                                           * `embed-english-light-v3.0`  384
                                           * `embed-multilingual-light-v3.0`  384

                                           * `embed-english-v2.0`  4096
                                           * `embed-english-light-v2.0`  1024
                                           * `embed-multilingual-v2.0`  768
            - input_type: typing.Optional[EmbedInputType].

            - embedding_types: typing.Optional[typing.List[EmbedRequestEmbeddingTypesItem]]. Specifies the types of embeddings you want to get back. Not required and default is None, which returns the Embed Floats response type. Can be one or more of the following types.

                                                                                             * `"float"`: Use this when you want to get back the default float embeddings. Valid for all models.
                                                                                             * `"int8"`: Use this when you want to get back signed int8 embeddings. Valid for only v3 models.
                                                                                             * `"uint8"`: Use this when you want to get back unsigned int8 embeddings. Valid for only v3 models.
                                                                                             * `"binary"`: Use this when you want to get back signed binary embeddings. Valid for only v3 models.
                                                                                             * `"ubinary"`: Use this when you want to get back unsigned binary embeddings. Valid for only v3 models.
            - truncate: typing.Optional[EmbedRequestTruncate]. One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.

                                                               Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

                                                               If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
        """
        _request: typing.Dict[str, typing.Any] = {"texts": texts}
        if model is not OMIT:
            _request["model"] = model
        if input_type is not OMIT:
            _request["input_type"] = input_type
        if embedding_types is not OMIT:
            _request["embedding_types"] = embedding_types
        if truncate is not OMIT:
            _request["truncate"] = truncate
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/embed"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EmbedResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def rerank(
        self,
        *,
        model: typing.Optional[str] = OMIT,
        query: str,
        documents: typing.List[RerankRequestDocumentsItem],
        top_n: typing.Optional[int] = OMIT,
        return_documents: typing.Optional[bool] = OMIT,
        max_chunks_per_doc: typing.Optional[int] = OMIT,
    ) -> RerankResponse:
        """
        This endpoint takes in a query and a list of texts and produces an ordered array with each text assigned a relevance score.

        Parameters:
            - model: typing.Optional[str]. The identifier of the model to use, one of : `rerank-english-v2.0`, `rerank-multilingual-v2.0`

            - query: str. The search query

            - documents: typing.List[RerankRequestDocumentsItem]. A list of document objects or strings to rerank.
                                                                  If a document is provided the text fields is required and all other fields will be preserved in the response.

                                                                  The total max chunks (length of documents * max_chunks_per_doc) must be less than 10000.

                                                                  We recommend a maximum of 1,000 documents for optimal endpoint performance.
            - top_n: typing.Optional[int]. The number of most relevant documents or indices to return, defaults to the length of the documents

            - return_documents: typing.Optional[bool]. - If false, returns results without the doc text - the api will return a list of {index, relevance score} where index is inferred from the list passed into the request.
                                                       - If true, returns results with the doc text passed in - the api will return an ordered list of {index, text, relevance score} where index + text refers to the list passed into the request.
            - max_chunks_per_doc: typing.Optional[int]. The maximum number of chunks to produce internally from a document
        ---
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.rerank(
            model="rerank-english-v2.0",
            query="What is the capital of the United States?",
            documents=[],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"query": query, "documents": documents}
        if model is not OMIT:
            _request["model"] = model
        if top_n is not OMIT:
            _request["top_n"] = top_n
        if return_documents is not OMIT:
            _request["return_documents"] = return_documents
        if max_chunks_per_doc is not OMIT:
            _request["max_chunks_per_doc"] = max_chunks_per_doc
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/rerank"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RerankResponse, _response.json())  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def classify(
        self,
        *,
        inputs: typing.List[str],
        examples: typing.List[ClassifyExample],
        model: typing.Optional[str] = OMIT,
        preset: typing.Optional[str] = OMIT,
        truncate: typing.Optional[ClassifyRequestTruncate] = OMIT,
    ) -> ClassifyResponse:
        """
        This endpoint makes a prediction about which label fits the specified text inputs best. To make a prediction, Classify uses the provided `examples` of text + label pairs as a reference.
        Note: [Fine-tuned models](https://docs.cohere.com/docs/classify-fine-tuning) trained on classification examples don't require the `examples` parameter to be passed in explicitly.

        Parameters:
            - inputs: typing.List[str]. A list of up to 96 texts to be classified. Each one must be a non-empty string.
                                        There is, however, no consistent, universal limit to the length a particular input can be. We perform classification on the first `x` tokens of each input, and `x` varies depending on which underlying model is powering classification. The maximum token length for each model is listed in the "max tokens" column [here](https://docs.cohere.com/docs/models).
                                        Note: by default the `truncate` parameter is set to `END`, so tokens exceeding the limit will be automatically dropped. This behavior can be disabled by setting `truncate` to `NONE`, which will result in validation errors for longer texts.
            - examples: typing.List[ClassifyExample]. An array of examples to provide context to the model. Each example is a text string and its associated label/class. Each unique label requires at least 2 examples associated with it; the maximum number of examples is 2500, and each example has a maximum length of 512 tokens. The values should be structured as `{text: "...",label: "..."}`.
                                                      Note: [Fine-tuned Models](https://docs.cohere.com/docs/classify-fine-tuning) trained on classification examples don't require the `examples` parameter to be passed in explicitly.
            - model: typing.Optional[str]. The identifier of the model. Currently available models are `embed-multilingual-v2.0`, `embed-english-light-v2.0`, and `embed-english-v2.0` (default). Smaller "light" models are faster, while larger models will perform better. [Fine-tuned models](https://docs.cohere.com/docs/fine-tuning) can also be supplied with their full ID.

            - preset: typing.Optional[str]. The ID of a custom playground preset. You can create presets in the [playground](https://dashboard.cohere.ai/playground/classify?model=large). If you use a preset, all other parameters become optional, and any included parameters will override the preset's parameters.

            - truncate: typing.Optional[ClassifyRequestTruncate]. One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
                                                                  Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
                                                                  If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.---
        from cohere import ClassifyExample, ClassifyRequestTruncate
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.classify(
            inputs=["Confirm your email address", "hey i need u to send some $"],
            examples=[
                ClassifyExample(
                    text="Dermatologists don't like her!",
                    label="Spam",
                ),
                ClassifyExample(
                    text="Hello, open to this?",
                    label="Spam",
                ),
                ClassifyExample(
                    text="I need help please wire me $1000 right now",
                    label="Spam",
                ),
                ClassifyExample(
                    text="Nice to know you ;)",
                    label="Spam",
                ),
                ClassifyExample(
                    text="Please help me?",
                    label="Spam",
                ),
                ClassifyExample(
                    text="Your parcel will be delivered today",
                    label="Not spam",
                ),
                ClassifyExample(
                    text="Review changes to our Terms and Conditions",
                    label="Not spam",
                ),
                ClassifyExample(
                    text="Weekly sync notes",
                    label="Not spam",
                ),
                ClassifyExample(
                    text="Re: Follow up from todays meeting",
                    label="Not spam",
                ),
                ClassifyExample(
                    text="Pre-read for tomorrow",
                    label="Not spam",
                ),
            ],
            preset="my-preset-a58sbd",
            truncate=ClassifyRequestTruncate.NONE,
        )
        """
        _request: typing.Dict[str, typing.Any] = {"inputs": inputs, "examples": examples}
        if model is not OMIT:
            _request["model"] = model
        if preset is not OMIT:
            _request["preset"] = preset
        if truncate is not OMIT:
            _request["truncate"] = truncate
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/classify"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassifyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def summarize(
        self,
        *,
        text: str,
        length: typing.Optional[SummarizeRequestLength] = OMIT,
        format: typing.Optional[SummarizeRequestFormat] = OMIT,
        model: typing.Optional[str] = OMIT,
        extractiveness: typing.Optional[SummarizeRequestExtractiveness] = OMIT,
        temperature: typing.Optional[float] = OMIT,
        additional_command: typing.Optional[str] = OMIT,
    ) -> SummarizeResponse:
        """
               This endpoint generates a summary in English for a given text.

               Parameters:
                   - text: str. The text to generate a summary for. Can be up to 100,000 characters long. Currently the only supported language is English.

                   - length: typing.Optional[SummarizeRequestLength]. One of `short`, `medium`, `long`, or `auto` defaults to `auto`. Indicates the approximate length of the summary. If `auto` is selected, the best option will be picked based on the input text.

                   - format: typing.Optional[SummarizeRequestFormat]. One of `paragraph`, `bullets`, or `auto`, defaults to `auto`. Indicates the style in which the summary will be delivered - in a free form paragraph or in bullet points. If `auto` is selected, the best option will be picked based on the input text.

                   - model: typing.Optional[str]. The identifier of the model to generate the summary with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental). Smaller, "light" models are faster, while larger models will perform better.

                   - extractiveness: typing.Optional[SummarizeRequestExtractiveness]. One of `low`, `medium`, `high`, or `auto`, defaults to `auto`. Controls how close to the original text the summary is. `high` extractiveness summaries will lean towards reusing sentences verbatim, while `low` extractiveness summaries will tend to paraphrase more. If `auto` is selected, the best option will be picked based on the input text.

                   - temperature: typing.Optional[float]. Ranges from 0 to 5. Controls the randomness of the output. Lower values tend to generate more predictable output, while higher values tend to generate more creative output. The sweet spot is typically between 0 and 1.

                   - additional_command: typing.Optional[str]. A free-form instruction for modifying how the summaries get generated. Should complete the sentence "Generate a summary _". Eg. "focusing on the next steps" or "written by Yoda"
               ---
               from cohere import (SummarizeRequestExtractiveness, SummarizeRequestFormat,
                                   SummarizeRequestLength)
               from cohere.client import Client

               client = Client(client_name="YOUR_CLIENT_NAME", token="YOUR_TOKEN", )
               client.summarize(text='Ice cream is a sweetened frozen food typically eaten as a snack or dessert. It may be made from milk or cream and is flavoured with a sweetener, either sugar or an alternative, and a spice, such as cocoa or vanilla, or with fruit such as strawberries or peaches. It can also be made by whisking a flavored cream base and liquid nitrogen together. Food coloring is sometimes added, in addition to stabilizers. The mixture is cooled below the freezing point of water and stirred to incorporate air spaces and to prevent detectable ice crystals from forming. The result is a smooth, semi-solid foam that is solid at very low temperatures (below 2 C or 35 F). It becomes more malleable as its temperature increases.

               The meaning of the name "ice cream" varies from one country to another. In some countries, such as the United States, "ice cream" applies only to a specific variety, and most governments regulate the commercial use of the various terms according to the relative quantities of the main ingredients, notably the amount of cream. Products that do not meet the criteria to be called ice cream are sometimes labelled "frozen dairy dessert" instead. In other countries, such as Italy and Argentina, one word is used fo
        all variants. Analogues made from dairy alternatives, such as goat"s or sheep"s milk, or milk substitutes (e.g., soy, cashew, coconut, almond milk or tofu), are available for those who are lactose intolerant, allergic to dairy protein or vegan.', length=SummarizeRequestLength.SHORT, format=SummarizeRequestFormat.PARAGRAPH, extractiveness=SummarizeRequestExtractiveness.LOW, )
        """
        _request: typing.Dict[str, typing.Any] = {"text": text}
        if length is not OMIT:
            _request["length"] = length
        if format is not OMIT:
            _request["format"] = format
        if model is not OMIT:
            _request["model"] = model
        if extractiveness is not OMIT:
            _request["extractiveness"] = extractiveness
        if temperature is not OMIT:
            _request["temperature"] = temperature
        if additional_command is not OMIT:
            _request["additional_command"] = additional_command
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/summarize"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SummarizeResponse, _response.json())  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tokenize(self, *, text: str, model: typing.Optional[str] = OMIT) -> TokenizeResponse:
        """
        This endpoint splits input text into smaller units called tokens using byte-pair encoding (BPE). To learn more about tokenization and byte pair encoding, see the tokens page.

        Parameters:
            - text: str. The string to be tokenized, the minimum text length is 1 character, and the maximum text length is 65536 characters.

            - model: typing.Optional[str]. An optional parameter to provide the model name. This will ensure that the tokenization uses the tokenizer used by that model.
        ---
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.tokenize(
            text="tokenize me! :D",
            model="command",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"text": text}
        if model is not OMIT:
            _request["model"] = model
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/tokenize"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TokenizeResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def detokenize(self, *, tokens: typing.List[int], model: typing.Optional[str] = OMIT) -> DetokenizeResponse:
        """
        This endpoint takes tokens using byte-pair encoding and returns their text representation. To learn more about tokenization and byte pair encoding, see the tokens page.

        Parameters:
            - tokens: typing.List[int]. The list of tokens to be detokenized.

            - model: typing.Optional[str]. An optional parameter to provide the model name. This will ensure that the detokenization is done by the tokenizer used by that model.
        ---
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.detokenize(
            tokens=[10104, 12221, 1315, 34, 1420, 69],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"tokens": tokens}
        if model is not OMIT:
            _request["model"] = model
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/detokenize"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DetokenizeResponse, _response.json())  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncClient:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: ClientEnvironment = ClientEnvironment.PRODUCTION,
        client_name: typing.Optional[str] = None,
        token: typing.Union[str, typing.Callable[[], str]],
        timeout: typing.Optional[float] = 60,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            client_name=client_name,
            token=token,
            httpx_client=httpx.AsyncClient(timeout=timeout) if httpx_client is None else httpx_client,
        )
        self.embed_jobs = AsyncEmbedJobsClient(client_wrapper=self._client_wrapper)
        self.datasets = AsyncDatasetsClient(client_wrapper=self._client_wrapper)
        self.connectors = AsyncConnectorsClient(client_wrapper=self._client_wrapper)

    async def chat_stream(
        self,
        *,
        message: str,
        model: typing.Optional[str] = OMIT,
        stream: typing_extensions.Literal[True],
        preamble_override: typing.Optional[str] = OMIT,
        chat_history: typing.Optional[typing.List[ChatMessage]] = OMIT,
        conversation_id: typing.Optional[str] = OMIT,
        prompt_truncation: typing.Optional[ChatStreamRequestPromptTruncation] = OMIT,
        connectors: typing.Optional[typing.List[ChatConnector]] = OMIT,
        search_queries_only: typing.Optional[bool] = OMIT,
        documents: typing.Optional[typing.List[ChatDocument]] = OMIT,
        citation_quality: typing.Optional[ChatStreamRequestCitationQuality] = OMIT,
        temperature: typing.Optional[float] = OMIT,
        max_tokens: typing.Optional[int] = OMIT,
        k: typing.Optional[int] = OMIT,
        p: typing.Optional[float] = OMIT,
        frequency_penalty: typing.Optional[float] = OMIT,
        presence_penalty: typing.Optional[float] = OMIT,
    ) -> typing.AsyncIterator[StreamedChatResponse]:
        """
        The `chat` endpoint allows users to have conversations with a Large Language Model (LLM) from Cohere. Users can send messages as part of a persisted conversation using the `conversation_id` parameter, or they can pass in their own conversation history using the `chat_history` parameter.

        The endpoint features additional parameters such as [connectors](https://docs.cohere.com/docs/connectors) and `documents` that enable conversations enriched by external knowledge. We call this ["Retrieval Augmented Generation"](https://docs.cohere.com/docs/retrieval-augmented-generation-rag), or "RAG". For a full breakdown of the Chat API endpoint, document and connector modes, and streaming (with code samples), see [this guide](https://docs.cohere.com/docs/cochat-beta).

        Parameters:
            - message: str. Accepts a string.
                            The chat message from the user to the model.

            - model: typing.Optional[str]. Defaults to `command`.

                                           The identifier of the model, which can be one of the existing Cohere models or the full ID for a [fine-tuned custom model](https://docs.cohere.com/docs/chat-fine-tuning).

                                           Compatible Cohere models are `command` and `command-light` as well as the experimental `command-nightly` and `command-light-nightly` variants. Read more about [Cohere models](https://docs.cohere.com/docs/models).

            - stream: typing_extensions.Literal[True].

            - preamble_override: typing.Optional[str]. When specified, the default Cohere preamble will be replaced with the provided one.

            - chat_history: typing.Optional[typing.List[ChatMessage]]. A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's `message`.

            - conversation_id: typing.Optional[str]. An alternative to `chat_history`. Previous conversations can be resumed by providing the conversation's identifier. The contents of `message` and the model's response will be stored as part of this conversation.

                                                     If a conversation with this id does not already exist, a new conversation will be created.

            - prompt_truncation: typing.Optional[ChatStreamRequestPromptTruncation]. Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.

                                                                                     Dictates how the prompt will be constructed.

                                                                                     With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.

                                                                                     With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.

            - connectors: typing.Optional[typing.List[ChatConnector]]. Accepts `{"id": "web-search"}`, and/or the `"id"` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.

                                                                       When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).

            - search_queries_only: typing.Optional[bool]. Defaults to `false`.

                                                          When `true`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's `message` will be generated.

            - documents: typing.Optional[typing.List[ChatDocument]]. A list of relevant documents that the model can use to enrich its reply. See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.

            - citation_quality: typing.Optional[ChatStreamRequestCitationQuality]. Defaults to `"accurate"`.

                                                                                   Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.

            - temperature: typing.Optional[float]. Defaults to `0.3`.

                                                   A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.

                                                   Randomness can be further maximized by increasing the  value of the `p` parameter.

            - max_tokens: typing.Optional[int]. The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.

            - k: typing.Optional[int]. Ensures only the top `k` most likely tokens are considered for generation at each step.
                                       Defaults to `0`, min value of `0`, max value of `500`.

            - p: typing.Optional[float]. Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
                                         Defaults to `0.75`. min value of `0.01`, max value of `0.99`.

            - frequency_penalty: typing.Optional[float]. Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.

            - presence_penalty: typing.Optional[float]. Defaults to `0.0`, min value of `0.0`, max value of `1.0`. Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
        """
        _request: typing.Dict[str, typing.Any] = {"message": message, "stream": stream}
        if model is not OMIT:
            _request["model"] = model
        if preamble_override is not OMIT:
            _request["preamble_override"] = preamble_override
        if chat_history is not OMIT:
            _request["chat_history"] = chat_history
        if conversation_id is not OMIT:
            _request["conversation_id"] = conversation_id
        if prompt_truncation is not OMIT:
            _request["prompt_truncation"] = prompt_truncation
        if connectors is not OMIT:
            _request["connectors"] = connectors
        if search_queries_only is not OMIT:
            _request["search_queries_only"] = search_queries_only
        if documents is not OMIT:
            _request["documents"] = documents
        if citation_quality is not OMIT:
            _request["citation_quality"] = citation_quality
        if temperature is not OMIT:
            _request["temperature"] = temperature
        if max_tokens is not OMIT:
            _request["max_tokens"] = max_tokens
        if k is not OMIT:
            _request["k"] = k
        if p is not OMIT:
            _request["p"] = p
        if frequency_penalty is not OMIT:
            _request["frequency_penalty"] = frequency_penalty
        if presence_penalty is not OMIT:
            _request["presence_penalty"] = presence_penalty
        async with self._client_wrapper.httpx_client.stream(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/chat"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        ) as _response:
            if 200 <= _response.status_code < 300:
                async for _text in _response.aiter_lines():
                    if len(_text) == 0:
                        continue
                    yield pydantic.parse_obj_as(StreamedChatResponse, json.loads(_text))  # type: ignore
                return
            await _response.aread()
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def chat(
        self,
        *,
        message: str,
        model: typing.Optional[str] = OMIT,
        stream: typing_extensions.Literal[False],
        preamble_override: typing.Optional[str] = OMIT,
        chat_history: typing.Optional[typing.List[ChatMessage]] = OMIT,
        conversation_id: typing.Optional[str] = OMIT,
        prompt_truncation: typing.Optional[ChatRequestPromptTruncation] = OMIT,
        connectors: typing.Optional[typing.List[ChatConnector]] = OMIT,
        search_queries_only: typing.Optional[bool] = OMIT,
        documents: typing.Optional[typing.List[ChatDocument]] = OMIT,
        citation_quality: typing.Optional[ChatRequestCitationQuality] = OMIT,
        temperature: typing.Optional[float] = OMIT,
        max_tokens: typing.Optional[int] = OMIT,
        k: typing.Optional[int] = OMIT,
        p: typing.Optional[float] = OMIT,
        frequency_penalty: typing.Optional[float] = OMIT,
        presence_penalty: typing.Optional[float] = OMIT,
    ) -> NonStreamedChatResponse:
        """
        The `chat` endpoint allows users to have conversations with a Large Language Model (LLM) from Cohere. Users can send messages as part of a persisted conversation using the `conversation_id` parameter, or they can pass in their own conversation history using the `chat_history` parameter.

        The endpoint features additional parameters such as [connectors](https://docs.cohere.com/docs/connectors) and `documents` that enable conversations enriched by external knowledge. We call this ["Retrieval Augmented Generation"](https://docs.cohere.com/docs/retrieval-augmented-generation-rag), or "RAG". For a full breakdown of the Chat API endpoint, document and connector modes, and streaming (with code samples), see [this guide](https://docs.cohere.com/docs/cochat-beta).

        Parameters:
            - message: str. Accepts a string.
                            The chat message from the user to the model.

            - model: typing.Optional[str]. Defaults to `command`.

                                           The identifier of the model, which can be one of the existing Cohere models or the full ID for a [fine-tuned custom model](https://docs.cohere.com/docs/chat-fine-tuning).

                                           Compatible Cohere models are `command` and `command-light` as well as the experimental `command-nightly` and `command-light-nightly` variants. Read more about [Cohere models](https://docs.cohere.com/docs/models).

            - stream: typing_extensions.Literal[False].

            - preamble_override: typing.Optional[str]. When specified, the default Cohere preamble will be replaced with the provided one.

            - chat_history: typing.Optional[typing.List[ChatMessage]]. A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's `message`.

            - conversation_id: typing.Optional[str]. An alternative to `chat_history`. Previous conversations can be resumed by providing the conversation's identifier. The contents of `message` and the model's response will be stored as part of this conversation.

                                                     If a conversation with this id does not already exist, a new conversation will be created.

            - prompt_truncation: typing.Optional[ChatRequestPromptTruncation]. Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.

                                                                               Dictates how the prompt will be constructed.

                                                                               With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.

                                                                               With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.

            - connectors: typing.Optional[typing.List[ChatConnector]]. Accepts `{"id": "web-search"}`, and/or the `"id"` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.

                                                                       When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).

            - search_queries_only: typing.Optional[bool]. Defaults to `false`.

                                                          When `true`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's `message` will be generated.

            - documents: typing.Optional[typing.List[ChatDocument]]. A list of relevant documents that the model can use to enrich its reply. See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.

            - citation_quality: typing.Optional[ChatRequestCitationQuality]. Defaults to `"accurate"`.

                                                                             Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.

            - temperature: typing.Optional[float]. Defaults to `0.3`.

                                                   A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.

                                                   Randomness can be further maximized by increasing the  value of the `p` parameter.

            - max_tokens: typing.Optional[int]. The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.

            - k: typing.Optional[int]. Ensures only the top `k` most likely tokens are considered for generation at each step.
                                       Defaults to `0`, min value of `0`, max value of `500`.

            - p: typing.Optional[float]. Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
                                         Defaults to `0.75`. min value of `0.01`, max value of `0.99`.

            - frequency_penalty: typing.Optional[float]. Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.

            - presence_penalty: typing.Optional[float]. Defaults to `0.0`, min value of `0.0`, max value of `1.0`. Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
        ---
        from cohere import (
            ChatMessage,
            ChatMessageRole,
            ChatRequestCitationQuality,
            ChatRequestPromptOverride,
            ChatRequestPromptTruncation,
            ChatRequestSearchOptions,
        )
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.chat(
            message="Can you give me a global market overview of solar panels?",
            stream=False,
            chat_history=[
                ChatMessage(
                    role=ChatMessageRole.CHATBOT,
                    message="Hi!",
                ),
                ChatMessage(
                    role=ChatMessageRole.CHATBOT,
                    message="How can I help you today?",
                ),
            ],
            prompt_truncation=ChatRequestPromptTruncation.OFF,
            citation_quality=ChatRequestCitationQuality.FAST,
            temperature=0.3,
            search_options=ChatRequestSearchOptions(),
            prompt_override=ChatRequestPromptOverride(),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"message": message, "stream": stream}
        if model is not OMIT:
            _request["model"] = model
        if preamble_override is not OMIT:
            _request["preamble_override"] = preamble_override
        if chat_history is not OMIT:
            _request["chat_history"] = chat_history
        if conversation_id is not OMIT:
            _request["conversation_id"] = conversation_id
        if prompt_truncation is not OMIT:
            _request["prompt_truncation"] = prompt_truncation
        if connectors is not OMIT:
            _request["connectors"] = connectors
        if search_queries_only is not OMIT:
            _request["search_queries_only"] = search_queries_only
        if documents is not OMIT:
            _request["documents"] = documents
        if citation_quality is not OMIT:
            _request["citation_quality"] = citation_quality
        if temperature is not OMIT:
            _request["temperature"] = temperature
        if max_tokens is not OMIT:
            _request["max_tokens"] = max_tokens
        if k is not OMIT:
            _request["k"] = k
        if p is not OMIT:
            _request["p"] = p
        if frequency_penalty is not OMIT:
            _request["frequency_penalty"] = frequency_penalty
        if presence_penalty is not OMIT:
            _request["presence_penalty"] = presence_penalty
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/chat"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(NonStreamedChatResponse, _response.json())  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_stream(
        self,
        *,
        prompt: str,
        model: typing.Optional[str] = OMIT,
        num_generations: typing.Optional[int] = OMIT,
        stream: typing_extensions.Literal[True],
        max_tokens: typing.Optional[int] = OMIT,
        truncate: typing.Optional[GenerateStreamRequestTruncate] = OMIT,
        temperature: typing.Optional[float] = OMIT,
        preset: typing.Optional[str] = OMIT,
        end_sequences: typing.Optional[typing.List[str]] = OMIT,
        stop_sequences: typing.Optional[typing.List[str]] = OMIT,
        k: typing.Optional[int] = OMIT,
        p: typing.Optional[float] = OMIT,
        frequency_penalty: typing.Optional[float] = OMIT,
        presence_penalty: typing.Optional[float] = OMIT,
        return_likelihoods: typing.Optional[GenerateStreamRequestReturnLikelihoods] = OMIT,
        logit_bias: typing.Optional[typing.Dict[str, float]] = OMIT,
        raw_prompting: typing.Optional[bool] = OMIT,
    ) -> typing.AsyncIterator[GenerateStreamedResponse]:
        """
        This endpoint generates realistic text conditioned on a given input.

        Parameters:
            - prompt: str. The input text that serves as the starting point for generating the response.
                           Note: The prompt will be pre-processed and modified before reaching the model.

            - model: typing.Optional[str]. The identifier of the model to generate with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental).
                                           Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
            - num_generations: typing.Optional[int]. The maximum number of generations that will be returned. Defaults to `1`, min value of `1`, max value of `5`.

            - stream: typing_extensions.Literal[True].

            - max_tokens: typing.Optional[int]. The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.

                                                This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.

                                                Can only be set to `0` if `return_likelihoods` is set to `ALL` to get the likelihood of the prompt.

            - truncate: typing.Optional[GenerateStreamRequestTruncate]. One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.

                                                                        Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

                                                                        If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
            - temperature: typing.Optional[float]. A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
                                                   Defaults to `0.75`, min value of `0.0`, max value of `5.0`.

            - preset: typing.Optional[str]. Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.ai/playground/generate).
                                            When a preset is specified, the `prompt` parameter becomes optional, and any included parameters will override the preset's parameters.

            - end_sequences: typing.Optional[typing.List[str]]. The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.

            - stop_sequences: typing.Optional[typing.List[str]]. The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.

            - k: typing.Optional[int]. Ensures only the top `k` most likely tokens are considered for generation at each step.
                                       Defaults to `0`, min value of `0`, max value of `500`.

            - p: typing.Optional[float]. Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
                                         Defaults to `0.75`. min value of `0.01`, max value of `0.99`.

            - frequency_penalty: typing.Optional[float]. Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.

                                                         Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.

            - presence_penalty: typing.Optional[float]. Defaults to `0.0`, min value of `0.0`, max value of `1.0`.

                                                        Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.

                                                        Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.

            - return_likelihoods: typing.Optional[GenerateStreamRequestReturnLikelihoods]. One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.

                                                                                           If `GENERATION` is selected, the token likelihoods will only be provided for generated text.

                                                                                           If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
            - logit_bias: typing.Optional[typing.Dict[str, float]]. Certain models support the `logit_bias` parameter.

                                                                    Used to prevent the model from generating unwanted tokens or to incentivize it to include desired tokens. The format is `{token_id: bias}` where bias is a float between -10 and 10. Tokens can be obtained from text using [Tokenize](/reference/tokenize).

                                                                    For example, if the value `{'11': -10}` is provided, the model will be very unlikely to include the token 11 (`"\n"`, the newline character) anywhere in the generated text. In contrast `{'11': 10}` will result in generations that nearly only contain that token. Values between -10 and 10 will proportionally affect the likelihood of the token appearing in the generated text.
            - raw_prompting: typing.Optional[bool]. When enabled, the user's prompt will be sent to the model without any pre-processing.
        """
        _request: typing.Dict[str, typing.Any] = {"prompt": prompt, "stream": stream}
        if model is not OMIT:
            _request["model"] = model
        if num_generations is not OMIT:
            _request["num_generations"] = num_generations
        if max_tokens is not OMIT:
            _request["max_tokens"] = max_tokens
        if truncate is not OMIT:
            _request["truncate"] = truncate
        if temperature is not OMIT:
            _request["temperature"] = temperature
        if preset is not OMIT:
            _request["preset"] = preset
        if end_sequences is not OMIT:
            _request["end_sequences"] = end_sequences
        if stop_sequences is not OMIT:
            _request["stop_sequences"] = stop_sequences
        if k is not OMIT:
            _request["k"] = k
        if p is not OMIT:
            _request["p"] = p
        if frequency_penalty is not OMIT:
            _request["frequency_penalty"] = frequency_penalty
        if presence_penalty is not OMIT:
            _request["presence_penalty"] = presence_penalty
        if return_likelihoods is not OMIT:
            _request["return_likelihoods"] = return_likelihoods
        if logit_bias is not OMIT:
            _request["logit_bias"] = logit_bias
        if raw_prompting is not OMIT:
            _request["raw_prompting"] = raw_prompting
        async with self._client_wrapper.httpx_client.stream(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/generate"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        ) as _response:
            if 200 <= _response.status_code < 300:
                async for _text in _response.aiter_lines():
                    if len(_text) == 0:
                        continue
                    yield pydantic.parse_obj_as(GenerateStreamedResponse, json.loads(_text))  # type: ignore
                return
            await _response.aread()
            if _response.status_code == 400:
                raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 429:
                raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            if _response.status_code == 500:
                raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate(
        self,
        *,
        prompt: str,
        model: typing.Optional[str] = OMIT,
        num_generations: typing.Optional[int] = OMIT,
        stream: typing_extensions.Literal[False],
        max_tokens: typing.Optional[int] = OMIT,
        truncate: typing.Optional[GenerateRequestTruncate] = OMIT,
        temperature: typing.Optional[float] = OMIT,
        preset: typing.Optional[str] = OMIT,
        end_sequences: typing.Optional[typing.List[str]] = OMIT,
        stop_sequences: typing.Optional[typing.List[str]] = OMIT,
        k: typing.Optional[int] = OMIT,
        p: typing.Optional[float] = OMIT,
        frequency_penalty: typing.Optional[float] = OMIT,
        presence_penalty: typing.Optional[float] = OMIT,
        return_likelihoods: typing.Optional[GenerateRequestReturnLikelihoods] = OMIT,
        logit_bias: typing.Optional[typing.Dict[str, float]] = OMIT,
        raw_prompting: typing.Optional[bool] = OMIT,
    ) -> Generation:
        """
        This endpoint generates realistic text conditioned on a given input.

        Parameters:
            - prompt: str. The input text that serves as the starting point for generating the response.
                           Note: The prompt will be pre-processed and modified before reaching the model.

            - model: typing.Optional[str]. The identifier of the model to generate with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental).
                                           Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
            - num_generations: typing.Optional[int]. The maximum number of generations that will be returned. Defaults to `1`, min value of `1`, max value of `5`.

            - stream: typing_extensions.Literal[False].

            - max_tokens: typing.Optional[int]. The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.

                                                This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.

                                                Can only be set to `0` if `return_likelihoods` is set to `ALL` to get the likelihood of the prompt.

            - truncate: typing.Optional[GenerateRequestTruncate]. One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.

                                                                  Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

                                                                  If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
            - temperature: typing.Optional[float]. A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
                                                   Defaults to `0.75`, min value of `0.0`, max value of `5.0`.

            - preset: typing.Optional[str]. Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.ai/playground/generate).
                                            When a preset is specified, the `prompt` parameter becomes optional, and any included parameters will override the preset's parameters.

            - end_sequences: typing.Optional[typing.List[str]]. The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.

            - stop_sequences: typing.Optional[typing.List[str]]. The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.

            - k: typing.Optional[int]. Ensures only the top `k` most likely tokens are considered for generation at each step.
                                       Defaults to `0`, min value of `0`, max value of `500`.

            - p: typing.Optional[float]. Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
                                         Defaults to `0.75`. min value of `0.01`, max value of `0.99`.

            - frequency_penalty: typing.Optional[float]. Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.

                                                         Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.

            - presence_penalty: typing.Optional[float]. Defaults to `0.0`, min value of `0.0`, max value of `1.0`.

                                                        Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.

                                                        Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.

            - return_likelihoods: typing.Optional[GenerateRequestReturnLikelihoods]. One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.

                                                                                     If `GENERATION` is selected, the token likelihoods will only be provided for generated text.

                                                                                     If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
            - logit_bias: typing.Optional[typing.Dict[str, float]]. Certain models support the `logit_bias` parameter.

                                                                    Used to prevent the model from generating unwanted tokens or to incentivize it to include desired tokens. The format is `{token_id: bias}` where bias is a float between -10 and 10. Tokens can be obtained from text using [Tokenize](/reference/tokenize).

                                                                    For example, if the value `{'11': -10}` is provided, the model will be very unlikely to include the token 11 (`"\n"`, the newline character) anywhere in the generated text. In contrast `{'11': 10}` will result in generations that nearly only contain that token. Values between -10 and 10 will proportionally affect the likelihood of the token appearing in the generated text.
            - raw_prompting: typing.Optional[bool]. When enabled, the user's prompt will be sent to the model without any pre-processing.
        ---
        from cohere import GenerateRequestReturnLikelihoods, GenerateRequestTruncate
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.generate(
            prompt="Please explain to me how LLMs work",
            stream=False,
            truncate=GenerateRequestTruncate.NONE,
            preset="my-preset-a58sbd",
            return_likelihoods=GenerateRequestReturnLikelihoods.GENERATION,
        )
        """
        _request: typing.Dict[str, typing.Any] = {"prompt": prompt, "stream": stream}
        if model is not OMIT:
            _request["model"] = model
        if num_generations is not OMIT:
            _request["num_generations"] = num_generations
        if max_tokens is not OMIT:
            _request["max_tokens"] = max_tokens
        if truncate is not OMIT:
            _request["truncate"] = truncate
        if temperature is not OMIT:
            _request["temperature"] = temperature
        if preset is not OMIT:
            _request["preset"] = preset
        if end_sequences is not OMIT:
            _request["end_sequences"] = end_sequences
        if stop_sequences is not OMIT:
            _request["stop_sequences"] = stop_sequences
        if k is not OMIT:
            _request["k"] = k
        if p is not OMIT:
            _request["p"] = p
        if frequency_penalty is not OMIT:
            _request["frequency_penalty"] = frequency_penalty
        if presence_penalty is not OMIT:
            _request["presence_penalty"] = presence_penalty
        if return_likelihoods is not OMIT:
            _request["return_likelihoods"] = return_likelihoods
        if logit_bias is not OMIT:
            _request["logit_bias"] = logit_bias
        if raw_prompting is not OMIT:
            _request["raw_prompting"] = raw_prompting
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/generate"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Generation, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def embed(
        self,
        *,
        texts: typing.List[str],
        model: typing.Optional[str] = OMIT,
        input_type: typing.Optional[EmbedInputType] = OMIT,
        embedding_types: typing.Optional[typing.List[EmbedRequestEmbeddingTypesItem]] = OMIT,
        truncate: typing.Optional[EmbedRequestTruncate] = OMIT,
    ) -> EmbedResponse:
        """
        This endpoint returns text embeddings. An embedding is a list of floating point numbers that captures semantic information about the text that it represents.

        Embeddings can be used to create text classifiers as well as empower semantic search. To learn more about embeddings, see the embedding page.

        If you want to learn more how to use the embedding model, have a look at the [Semantic Search Guide](/docs/semantic-search).

        Parameters:
            - texts: typing.List[str]. An array of strings for the model to embed. Maximum number of texts per call is `96`. We recommend reducing the length of each text to be under `512` tokens for optimal quality.

            - model: typing.Optional[str]. Defaults to embed-english-v2.0

                                           The identifier of the model. Smaller "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.

                                           Available models and corresponding embedding dimensions:

                                           * `embed-english-v3.0`  1024
                                           * `embed-multilingual-v3.0`  1024
                                           * `embed-english-light-v3.0`  384
                                           * `embed-multilingual-light-v3.0`  384

                                           * `embed-english-v2.0`  4096
                                           * `embed-english-light-v2.0`  1024
                                           * `embed-multilingual-v2.0`  768
            - input_type: typing.Optional[EmbedInputType].

            - embedding_types: typing.Optional[typing.List[EmbedRequestEmbeddingTypesItem]]. Specifies the types of embeddings you want to get back. Not required and default is None, which returns the Embed Floats response type. Can be one or more of the following types.

                                                                                             * `"float"`: Use this when you want to get back the default float embeddings. Valid for all models.
                                                                                             * `"int8"`: Use this when you want to get back signed int8 embeddings. Valid for only v3 models.
                                                                                             * `"uint8"`: Use this when you want to get back unsigned int8 embeddings. Valid for only v3 models.
                                                                                             * `"binary"`: Use this when you want to get back signed binary embeddings. Valid for only v3 models.
                                                                                             * `"ubinary"`: Use this when you want to get back unsigned binary embeddings. Valid for only v3 models.
            - truncate: typing.Optional[EmbedRequestTruncate]. One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.

                                                               Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

                                                               If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
        """
        _request: typing.Dict[str, typing.Any] = {"texts": texts}
        if model is not OMIT:
            _request["model"] = model
        if input_type is not OMIT:
            _request["input_type"] = input_type
        if embedding_types is not OMIT:
            _request["embedding_types"] = embedding_types
        if truncate is not OMIT:
            _request["truncate"] = truncate
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/embed"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EmbedResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def rerank(
        self,
        *,
        model: typing.Optional[str] = OMIT,
        query: str,
        documents: typing.List[RerankRequestDocumentsItem],
        top_n: typing.Optional[int] = OMIT,
        return_documents: typing.Optional[bool] = OMIT,
        max_chunks_per_doc: typing.Optional[int] = OMIT,
    ) -> RerankResponse:
        """
        This endpoint takes in a query and a list of texts and produces an ordered array with each text assigned a relevance score.

        Parameters:
            - model: typing.Optional[str]. The identifier of the model to use, one of : `rerank-english-v2.0`, `rerank-multilingual-v2.0`

            - query: str. The search query

            - documents: typing.List[RerankRequestDocumentsItem]. A list of document objects or strings to rerank.
                                                                  If a document is provided the text fields is required and all other fields will be preserved in the response.

                                                                  The total max chunks (length of documents * max_chunks_per_doc) must be less than 10000.

                                                                  We recommend a maximum of 1,000 documents for optimal endpoint performance.
            - top_n: typing.Optional[int]. The number of most relevant documents or indices to return, defaults to the length of the documents

            - return_documents: typing.Optional[bool]. - If false, returns results without the doc text - the api will return a list of {index, relevance score} where index is inferred from the list passed into the request.
                                                       - If true, returns results with the doc text passed in - the api will return an ordered list of {index, text, relevance score} where index + text refers to the list passed into the request.
            - max_chunks_per_doc: typing.Optional[int]. The maximum number of chunks to produce internally from a document
        ---
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.rerank(
            model="rerank-english-v2.0",
            query="What is the capital of the United States?",
            documents=[],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"query": query, "documents": documents}
        if model is not OMIT:
            _request["model"] = model
        if top_n is not OMIT:
            _request["top_n"] = top_n
        if return_documents is not OMIT:
            _request["return_documents"] = return_documents
        if max_chunks_per_doc is not OMIT:
            _request["max_chunks_per_doc"] = max_chunks_per_doc
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/rerank"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RerankResponse, _response.json())  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def classify(
        self,
        *,
        inputs: typing.List[str],
        examples: typing.List[ClassifyExample],
        model: typing.Optional[str] = OMIT,
        preset: typing.Optional[str] = OMIT,
        truncate: typing.Optional[ClassifyRequestTruncate] = OMIT,
    ) -> ClassifyResponse:
        """
        This endpoint makes a prediction about which label fits the specified text inputs best. To make a prediction, Classify uses the provided `examples` of text + label pairs as a reference.
        Note: [Fine-tuned models](https://docs.cohere.com/docs/classify-fine-tuning) trained on classification examples don't require the `examples` parameter to be passed in explicitly.

        Parameters:
            - inputs: typing.List[str]. A list of up to 96 texts to be classified. Each one must be a non-empty string.
                                        There is, however, no consistent, universal limit to the length a particular input can be. We perform classification on the first `x` tokens of each input, and `x` varies depending on which underlying model is powering classification. The maximum token length for each model is listed in the "max tokens" column [here](https://docs.cohere.com/docs/models).
                                        Note: by default the `truncate` parameter is set to `END`, so tokens exceeding the limit will be automatically dropped. This behavior can be disabled by setting `truncate` to `NONE`, which will result in validation errors for longer texts.
            - examples: typing.List[ClassifyExample]. An array of examples to provide context to the model. Each example is a text string and its associated label/class. Each unique label requires at least 2 examples associated with it; the maximum number of examples is 2500, and each example has a maximum length of 512 tokens. The values should be structured as `{text: "...",label: "..."}`.
                                                      Note: [Fine-tuned Models](https://docs.cohere.com/docs/classify-fine-tuning) trained on classification examples don't require the `examples` parameter to be passed in explicitly.
            - model: typing.Optional[str]. The identifier of the model. Currently available models are `embed-multilingual-v2.0`, `embed-english-light-v2.0`, and `embed-english-v2.0` (default). Smaller "light" models are faster, while larger models will perform better. [Fine-tuned models](https://docs.cohere.com/docs/fine-tuning) can also be supplied with their full ID.

            - preset: typing.Optional[str]. The ID of a custom playground preset. You can create presets in the [playground](https://dashboard.cohere.ai/playground/classify?model=large). If you use a preset, all other parameters become optional, and any included parameters will override the preset's parameters.

            - truncate: typing.Optional[ClassifyRequestTruncate]. One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
                                                                  Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
                                                                  If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.---
        from cohere import ClassifyExample, ClassifyRequestTruncate
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.classify(
            inputs=["Confirm your email address", "hey i need u to send some $"],
            examples=[
                ClassifyExample(
                    text="Dermatologists don't like her!",
                    label="Spam",
                ),
                ClassifyExample(
                    text="Hello, open to this?",
                    label="Spam",
                ),
                ClassifyExample(
                    text="I need help please wire me $1000 right now",
                    label="Spam",
                ),
                ClassifyExample(
                    text="Nice to know you ;)",
                    label="Spam",
                ),
                ClassifyExample(
                    text="Please help me?",
                    label="Spam",
                ),
                ClassifyExample(
                    text="Your parcel will be delivered today",
                    label="Not spam",
                ),
                ClassifyExample(
                    text="Review changes to our Terms and Conditions",
                    label="Not spam",
                ),
                ClassifyExample(
                    text="Weekly sync notes",
                    label="Not spam",
                ),
                ClassifyExample(
                    text="Re: Follow up from todays meeting",
                    label="Not spam",
                ),
                ClassifyExample(
                    text="Pre-read for tomorrow",
                    label="Not spam",
                ),
            ],
            preset="my-preset-a58sbd",
            truncate=ClassifyRequestTruncate.NONE,
        )
        """
        _request: typing.Dict[str, typing.Any] = {"inputs": inputs, "examples": examples}
        if model is not OMIT:
            _request["model"] = model
        if preset is not OMIT:
            _request["preset"] = preset
        if truncate is not OMIT:
            _request["truncate"] = truncate
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/classify"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassifyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def summarize(
        self,
        *,
        text: str,
        length: typing.Optional[SummarizeRequestLength] = OMIT,
        format: typing.Optional[SummarizeRequestFormat] = OMIT,
        model: typing.Optional[str] = OMIT,
        extractiveness: typing.Optional[SummarizeRequestExtractiveness] = OMIT,
        temperature: typing.Optional[float] = OMIT,
        additional_command: typing.Optional[str] = OMIT,
    ) -> SummarizeResponse:
        """
               This endpoint generates a summary in English for a given text.

               Parameters:
                   - text: str. The text to generate a summary for. Can be up to 100,000 characters long. Currently the only supported language is English.

                   - length: typing.Optional[SummarizeRequestLength]. One of `short`, `medium`, `long`, or `auto` defaults to `auto`. Indicates the approximate length of the summary. If `auto` is selected, the best option will be picked based on the input text.

                   - format: typing.Optional[SummarizeRequestFormat]. One of `paragraph`, `bullets`, or `auto`, defaults to `auto`. Indicates the style in which the summary will be delivered - in a free form paragraph or in bullet points. If `auto` is selected, the best option will be picked based on the input text.

                   - model: typing.Optional[str]. The identifier of the model to generate the summary with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental). Smaller, "light" models are faster, while larger models will perform better.

                   - extractiveness: typing.Optional[SummarizeRequestExtractiveness]. One of `low`, `medium`, `high`, or `auto`, defaults to `auto`. Controls how close to the original text the summary is. `high` extractiveness summaries will lean towards reusing sentences verbatim, while `low` extractiveness summaries will tend to paraphrase more. If `auto` is selected, the best option will be picked based on the input text.

                   - temperature: typing.Optional[float]. Ranges from 0 to 5. Controls the randomness of the output. Lower values tend to generate more predictable output, while higher values tend to generate more creative output. The sweet spot is typically between 0 and 1.

                   - additional_command: typing.Optional[str]. A free-form instruction for modifying how the summaries get generated. Should complete the sentence "Generate a summary _". Eg. "focusing on the next steps" or "written by Yoda"
               ---
               from cohere import (SummarizeRequestExtractiveness, SummarizeRequestFormat,
                                   SummarizeRequestLength)
               from cohere.client import AsyncClient

               client = AsyncClient(client_name="YOUR_CLIENT_NAME", token="YOUR_TOKEN", )
               await client.summarize(text='Ice cream is a sweetened frozen food typically eaten as a snack or dessert. It may be made from milk or cream and is flavoured with a sweetener, either sugar or an alternative, and a spice, such as cocoa or vanilla, or with fruit such as strawberries or peaches. It can also be made by whisking a flavored cream base and liquid nitrogen together. Food coloring is sometimes added, in addition to stabilizers. The mixture is cooled below the freezing point of water and stirred to incorporate air spaces and to prevent detectable ice crystals from forming. The result is a smooth, semi-solid foam that is solid at very low temperatures (below 2 C or 35 F). It becomes more malleable as its temperature increases.

               The meaning of the name "ice cream" varies from one country to another. In some countries, such as the United States, "ice cream" applies only to a specific variety, and most governments regulate the commercial use of the various terms according to the relative quantities of the main ingredients, notably the amount of cream. Products that do not meet the criteria to be called ice cream are sometimes labelled "frozen dairy dessert" instead. In other countries, such as Italy and Argentina, one word is used fo
        all variants. Analogues made from dairy alternatives, such as goat"s or sheep"s milk, or milk substitutes (e.g., soy, cashew, coconut, almond milk or tofu), are available for those who are lactose intolerant, allergic to dairy protein or vegan.', length=SummarizeRequestLength.SHORT, format=SummarizeRequestFormat.PARAGRAPH, extractiveness=SummarizeRequestExtractiveness.LOW, )
        """
        _request: typing.Dict[str, typing.Any] = {"text": text}
        if length is not OMIT:
            _request["length"] = length
        if format is not OMIT:
            _request["format"] = format
        if model is not OMIT:
            _request["model"] = model
        if extractiveness is not OMIT:
            _request["extractiveness"] = extractiveness
        if temperature is not OMIT:
            _request["temperature"] = temperature
        if additional_command is not OMIT:
            _request["additional_command"] = additional_command
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/summarize"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SummarizeResponse, _response.json())  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tokenize(self, *, text: str, model: typing.Optional[str] = OMIT) -> TokenizeResponse:
        """
        This endpoint splits input text into smaller units called tokens using byte-pair encoding (BPE). To learn more about tokenization and byte pair encoding, see the tokens page.

        Parameters:
            - text: str. The string to be tokenized, the minimum text length is 1 character, and the maximum text length is 65536 characters.

            - model: typing.Optional[str]. An optional parameter to provide the model name. This will ensure that the tokenization uses the tokenizer used by that model.
        ---
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.tokenize(
            text="tokenize me! :D",
            model="command",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"text": text}
        if model is not OMIT:
            _request["model"] = model
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/tokenize"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TokenizeResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def detokenize(self, *, tokens: typing.List[int], model: typing.Optional[str] = OMIT) -> DetokenizeResponse:
        """
        This endpoint takes tokens using byte-pair encoding and returns their text representation. To learn more about tokenization and byte pair encoding, see the tokens page.

        Parameters:
            - tokens: typing.List[int]. The list of tokens to be detokenized.

            - model: typing.Optional[str]. An optional parameter to provide the model name. This will ensure that the detokenization is done by the tokenizer used by that model.
        ---
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.detokenize(
            tokens=[10104, 12221, 1315, 34, 1420, 69],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"tokens": tokens}
        if model is not OMIT:
            _request["model"] = model
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/detokenize"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DetokenizeResponse, _response.json())  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: ClientEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")
